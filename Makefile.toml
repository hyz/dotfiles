

[config]
default_to_workspace = false
min_version = "0.32.1"

[config.modify_core_tasks]
private = true
namespace = "default"

[env]
RUST_RECURSION_COUNT = "0"

[tasks.all]
description = "Build Seed and examples"
dependencies = [] # ["build", "build_examples"]

[tasks.build]
description = "Build only Seed"
command = "cargo"
args = ["build"]

[tasks.build_release]
extend = "build"
description = "Build only Seed in relase mode"
args = ["build", "--release"]

[tasks.start]
description = "Start chosen example. Ex: 'cargo make start counter'"
command = "cargo"
args = ["make", "--cwd", "./examples/${@}", "start"]

[tasks.start_release]
extend = "start"
description = "Start chosen example in release mode. Ex: 'cargo make start counter'"
args = ["make", "--cwd", "./examples/${@}", "start_release"]

[tasks.start_server]
description = "Start server of chosen example (only a few have one). Ex: 'cargo make start_server websocket'"
command = "cargo"
args = ["make", "--cwd", "./examples/${@}", "start_server"]

[tasks.start_server_release]
extend = "start_server"
description = "Start server of chosen example (only a few have one) in release mode. Ex: 'cargo make start_server websocket'"
args = ["make", "--cwd", "./examples/${@}", "start_server_release"]

[tasks.default_build]
description = "Build with wasm-pack"
command = "wasm-pack"
args = ["build", "--target", "web", "--out-name", "package", "--dev"]
dependencies = ["default::install-wasm-pack"]

[tasks.default_build_release]
extend = "default_build"
description = "Build with wasm-pack in release mode"
args = ["build", "--target", "web", "--out-name", "package", "--release"]

[tasks.default_start]
description = "Build and start microserver"
install_crate = { crate_name = "microserver", binary = "microserver", test_arg = "-h" }
command = "microserver"
args = ["--port", "8000"]
dependencies = ["build"]

[tasks.default_start_release]
extend = "default_start"
description = "Build and start microserver in release mode"
dependencies = ["build_release"]

##############################################################
[tasks.duckscript-example]
script_runner = "@duckscript"
script = [
'''
task_name = get_env CARGO_MAKE_CURRENT_TASK_NAME
echo The currently running cargo make task is: ${task_name}

# since all env vars are auto loaded as duckscript variables by cargo-make
# you can access them directly
echo The currently running cargo make task is: ${CARGO_MAKE_CURRENT_TASK_NAME}

cd .. # this changes cargo-make current working directory (cargo-make will revert to original directory after script execution)
pwd
set_env CARGO_MAKE_CURRENT_TASK_NAME tricking_cargo_make
'''
]


[tasks.run-task-from-duckscript]
script_runner = "@duckscript"
script = [
'''
echo first invocation of echo1 task:
cm_run_task echo1
echo second invocation of echo1 task:
cm_run_task echo1

echo running task: echo2:
cm_run_task echo2
'''
]

[tasks.echo1]
command = "echo"
args = ["1"]

[tasks.echo2]
command = "echo"
args = ["2"]

[tasks.cargo-script]
env = { CARGO_MAKE_RUST_SCRIPT_PROVIDER = "cargo-script" }
script_runner = "@rust"
script = [
'''
fn main() {
    println!("test");
}
'''
]

[tasks.cargo-play]
env = { CARGO_MAKE_RUST_SCRIPT_PROVIDER = "cargo-play" }
script_runner = "@rust"
script = [
'''
fn main() {
    println!("test");
}
'''
]

[tasks.varargs]
# script_runner = "@duckscript"
command = "echo"
args = [ "args are:", "-o=${@}" ]

[tasks.merge-1]
script_runner = "@duckscript"
script = [
'''
# set_env SPRITES_LIST ${@}
echo SPRITES_LIST: ${SPRITES_LIST}
pwd
cm_run_task merge-v1
'''
]

[tasks.rg]
script_runner = "@shell"
script = ['''
rg -uw setTimeout src
rg -uw onRespawn src
'''
]

[tasks.exdeps]
script_runner = "python"
script_extension = "py"
script = ["""
import subprocess, shlex, tempfile

def popen(cmd, stdin=None):
    return subprocess.Popen(shlex.split(cmd), stdout=subprocess.PIPE, stdin=stdin, encoding='utf-8')

with popen('''rg -u '^import' src''') as xp1:
    with popen('''tee all-imports''', stdin=xp1.stdout) as xp2:
        #tmpf = io.StringIO()
        with tempfile.TemporaryFile(mode='w+t') as tmpf:
            for line in xp2.stdout:
                line = line.strip().replace('"', "'")
                if "'" in line:
                    _, d, _ = line.split("'", 2)
                    if not d.startswith("."):
                        print(f"{d}\t{line}", file=tmpf)
            tmpf.seek(0)
            with popen('''awk '{print $1}' ''', stdin=tmpf) as xp3:
                with popen('''sort ''', stdin=xp3.stdout) as xp4:
                    with popen('''uniq ''', stdin=xp4.stdout) as xp5:
                        for line in xp5.stdout:
                            print(line.strip())
"""
]

## cargo make merge-1 -e SPRITES_LIST=..\imgs\tesla\tesla1.txt -e OUTFILE=tesla.png
## cargo run --bin list -- tella | python merge-v.py tmp.png
[tasks.merge-v1]
description = "Populate styles"
script_runner = "python"
script_extension = "py"
env = { STYLES_ENDPOINT = "css_properties.json", STYLE_NAMES_FILE = "styles/style_names.rs" }
script = [
'''
import sys, os
import numpy as np
from PIL import Image

def merge(images, outfile):
    min_img_shape = sorted([(np.sum(i.size), i.size) for i in images])[0][1]
    img_merge = np.vstack(
        (np.asarray(i.resize(min_img_shape, Image.ANTIALIAS)) for i in images))
    img_merge = Image.fromarray(img_merge)
    img_merge.save(outfile)

def images(images, basedir):
    images = filter(lambda e:e, map(str.strip, images) )
    images = list(images)
    print(images, sep='\n') #; sys.exit(0)
    return [ Image.open( os.path.join(basedir, it.replace('\\','/')) ) for it in images ]

def envargs():
	# return sys.stdin, "."
	infile = os.getenv("SPRITES_LIST")
	assert infile, "-e SPRITES_LIST=..."
	outfile = os.getenv("OUTFILE", infile+".png") #os.path.splitext(infile)[0] + ".png"
	return open(infile), os.path.dirname(infile), outfile

#print(os.getcwd(), "${STYLES_ENDPOINT}")
infile, basedir, outfile = envargs()
images = images(infile, basedir)
merge(images, outfile)

'''
]

#$ cat filelist.txt
# file 1.mp3
# file 2.mp3
# file 3.mp3
#
#ffmpeg-concat:
#	ffmpeg -f concat -i filelist.txt -c copy output.mp3

[tasks.ffmpeg-concat]
description = "ffmpeg concat"
script_runner = "python"
script_extension = "py"
env = { INLIS = "input.txt", OUTPUT = "output" }
script = [
'''
import sys, os

def convert(infilename, outfilename):
	with open(infilename) as f:
		fs = filter(lambda e:e, map(str.strip, f) )
		fs = list(fs)
		print(*fs, sep='\n') #; sys.exit(0)
		_, ext = os.path.splitext(fs[0])
		lis = []
		for i,f in enumerate(fs):
			lis.append(f"{i}{ext}")
			os.link(f, os.path.join("tmp",lis[-1]))
		xfn = "tmp/input-files.txt" #os.path.join("tmp", infilename)
		with open(xfn, "w") as xf:
			print( *map(lambda p: f"file {p}", lis), sep="\n", file=xf)
			return xfn, f"{outfilename}{ext}"
		#return [ Image.open( os.path.join(basedir, it.replace('\\','/')) ) for it in images ]

def main(infilename, outfilename):
	infilename, outfilename = convert(infilename, outfilename)
	print(f"ffmpeg -f concat -i {infilename} -c copy {outfilename}")
	os.system(f"ffmpeg -f concat -i {infilename} -c copy {outfilename}")

ifn = os.getenv("INLIS")
ofn = os.getenv("OUTPUT")
assert os.path.exists(ifn) and ofn, f"{ifn} {ofn}\n\tcargo make ffmpeg-concat -e INLIS=... -e OUTPUT=...\n"
main(ifn, ofn)

'''
]

[tasks.copy-yew-static-to-dist]
command = "cargo"
args = ["make", "recur-tree-copy_rs", "src-yew/static", "dist" ]

[tasks.recur-tree-copy_rs]
###https://github.com/sagiegurari/cargo-make/tree/0.12.0#usage-task-command-script-task-examplerust
script_runner = "@rust"
script_extension = "rs"
script = ["""#[allow(non_snake_case)]
use std::fs;
use std::path::{Path, PathBuf};

fn main() -> std::io::Result<()> {
    //println!("args  :: {:?}", std::env::args().skip(1).collect::<std::vec::Vec<_>>());
    let arg1 = std::env::args().nth(1).expect("SRC");//var("SRCDIR_");
    let arg2 = std::env::args().nth(2).expect("DEST");//var("DESTDIR_");
    let src = Path::new(&arg1);
    let dest = PathBuf::from(&arg2);

    if !src.exists() {
        panic!("not exists: {}", src.display());
    }
    let dest = if !arg1.ends_with("/") && arg2.ends_with("/") {
        let dest = dest.join(src.file_name().unwrap());
        fs::create_dir_all(&dest).expect("dest");
        dest
    } else {
        dest
    };
    if dest.canonicalize()?.starts_with(src.canonicalize()?) {
        panic!("**dangerous**: `{}` '{}'", src.display(), dest.display());
    }

    println!("{:?} -> {:?}", src.canonicalize(), dest.canonicalize() );
    recur_copy_tree(src, dest)
}

fn recur_copy_tree(path1: &Path, path2: PathBuf) -> std::io::Result<()> {
    for entry in fs::read_dir(path1)? {
        let entry = entry?;
        let meta = entry.metadata()?;
        let path = entry.path();
        let dest = path2.join(path.file_name().unwrap());
        if meta.is_dir() || meta.is_file() {
            println!("{} -> {}", path.display(), dest.display());
            if meta.is_dir() {
                fs::create_dir_all(&dest).expect("create dest dir");
                recur_copy_tree(&path, dest)?;
            } else {
                fs::copy(path, dest).unwrap(); //std::io::copy
            }
        } else {
            eprintln!("!!!skip {}: {:?}", path.display(), meta.file_type());
        }
    }
    Ok(())
}
"""]

